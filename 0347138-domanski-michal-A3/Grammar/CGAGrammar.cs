//Grammar framework by Martin Ilcik. In case you are interested in PR/DA in this field, contact ilcik@cg.tuwien.ac.at
using System;
using System.Collections.Generic;
using System.Text;

namespace SimpleCGA.Grammar
{
    public class CGAGrammar
    {
        /// <summary>
        /// Random for the probability selection.
        /// </summary>
        Random Rnd = new Random();

        /// <summary>
        /// Collection of rules with some additional functionality
        /// </summary>
        public readonly RulesManager Rules = new RulesManager();

        /// <summary>
        /// List of axioms, all are derived independently (except you implement Task 7).
        /// </summary>
        public readonly List<Axiom> Axioms = new List<Axiom>();

        /// <summary>
        /// Set of terminal symbols, there must exist a corresponding class derived from TerminalShape with the same name.
        /// </summary>
        public readonly HashSet<string> Terminals = new HashSet<string>();

        protected StringBuilder Errors = new StringBuilder();

        /// <summary>
        /// Errors collected during the evaluation
        /// </summary>
        public string EvaluationErrors { get { return Errors.ToString(); } }

        /// <summary>
        /// Add an error to the list of errors caught during the evaluation.
        /// </summary>
        /// <param name="error">The common format is "Type of error (where if trackable): Explanation".</param>
        public void ReportError(string error)
        {
            Errors.AppendLine(error);
        }

        /// <summary>
        /// Clears all contents of the grammar.
        /// </summary>
        public void Clear()
        {
            Rules.RulesList.Clear();
            Axioms.Clear();
            Terminals.Clear();
            Errors.Clear();
        }

        /// <summary>
        /// For the selected shape all suitable rules are found, one is stochastically selected and applied to the input.
        /// </summary>
        /// <param name="shape">Shape which was selected for rule application.</param>
        /// <returns>A list of shapes generated by applying a rule on the input shape.</returns>
        internal IList<Shape> DerivationStep(Shape shape)
        {
            //TODO Task 4d pass the whole semantics for matching 
            var match = Rules.Matching(shape.Symbol.Name);
            var selectedValue = Rnd.NextDouble() * match[match.Count - 1].Key;
            
            int i = 0;
            while ((i < match.Count - 1) && (match[i].Key < selectedValue))
                ++i;

            return match[i].Value.Apply(shape);
        }

        //TODO Task 7: Design a method for the parallel derivation step (select a rule and applies it to the input shapes)
        //   internal IList<IList<Shape>> DerivationStep(IEnumerable<Shape> shapes)

        /// <summary>
        /// Adds a new terminal symbol to the grammar.
        /// </summary>
        /// <param name="symbol">New terminal symbol.</param>
        public void AddTerminal(string symbol)
        {
            Terminals.Add(symbol);
        }

        /// <summary>
        /// Addes a new axiom to the grammar.
        /// </summary>
        /// <param name="symbol">Symbol name of the axiom. All other attributes are default.</param>
        public void AddAxiom(string symbol, bool parallel = false)
        {
            Axioms.Add(new Axiom(this, symbol, parallel));
        }

        /// <summary>
        /// Evaluates all axioms in the grammar by applying matching procedural rules.
        /// </summary>
        /// <returns>All terminal shapes evaluated from all axioms in the grammar.</returns>
        public IEnumerable<Shape> Evaluate()
        {
            Errors.Clear();

            foreach (var item in Axioms)
                foreach (var shape in item.Evaluate())
                    yield return shape;
        }

        /// <summary>
        /// Default maximum number of derivation steps
        /// </summary>
        public int StepsThreshold = 65536;
    }
}
